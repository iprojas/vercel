{"ast":null,"code":"import _objectSpread from\"C:/Users/56994/Desktop/vercel/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"C:/Users/56994/Desktop/vercel/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"C:/Users/56994/Desktop/vercel/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{render}from'react-dom';import React,{useState}from'react';import{useSprings,animated,interpolate}from'react-spring';import{useGesture}from'react-with-gesture';import'./styles.css';import{jsx as _jsx}from\"react/jsx-runtime\";var cards=['https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg','https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg','https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg'];// These two are just helpers, they curate spring data, values that are later being interpolated into css\nvar to=function to(i){return{x:0,y:i*-4,scale:1,rot:-10+Math.random()*20,delay:i*100};};var from=function from(i){return _defineProperty({x:0,y:i*-4,rot:0,scale:1.5},\"y\",-1000);};// This is being used down there in the view, it interpolates rotation and scale into a css transform\nvar trans=function trans(r,s){return\"perspective(1500px) rotateX(30deg) rotateY(\".concat(r/10,\"deg) rotateZ(\").concat(r,\"deg) scale(\").concat(s,\")\");};function Deck(){var _useState=useState(function(){return new Set();}),_useState2=_slicedToArray(_useState,1),gone=_useState2[0];// The set flags all the cards that are flicked out\nvar _useSprings=useSprings(cards.length,function(i){return _objectSpread(_objectSpread({},to(i)),{},{from:from(i)});}),_useSprings2=_slicedToArray(_useSprings,2),props=_useSprings2[0],set=_useSprings2[1];// Create a bunch of springs using the helpers above\n// Create a gesture, we're interested in down-state, delta (current-pos - click-pos), direction and velocity\nvar bind=useGesture(function(_ref2){var _ref2$args=_slicedToArray(_ref2.args,1),index=_ref2$args[0],down=_ref2.down,_ref2$delta=_slicedToArray(_ref2.delta,1),xDelta=_ref2$delta[0],distance=_ref2.distance,_ref2$direction=_slicedToArray(_ref2.direction,1),xDir=_ref2$direction[0],velocity=_ref2.velocity;var trigger=velocity>0.15;// If you flick hard enough it should trigger the card to fly out\nvar dir=xDir<0?-1:1;// Direction should either point left or right\nif(!down&&trigger)gone.add(index);// If button/finger's up and trigger velocity is reached, we flag the card ready to fly out\nset(function(i){if(index!==i)return;// We're only interested in changing spring-data for the current spring\nvar isGone=gone.has(index);var x=isGone?(200+window.innerWidth)*dir:down?xDelta:0;// When a card is gone it flys out left or right, otherwise goes back to zero\nvar rot=xDelta/100+(isGone?dir*10*velocity:0);// How much the card tilts, flicking it harder makes it rotate faster\nvar scale=down?1.1:1;// Active cards lift up a bit\nreturn{x:x,rot:rot,scale:scale,delay:undefined,config:{friction:50,tension:down?800:isGone?200:500}};});if(!down&&gone.size===cards.length)setTimeout(function(){return gone.clear()||set(function(i){return to(i);});},6000);});// Now we're just mapping the animated values to our view, that's it. Btw, this component only renders once. :-)\nreturn props.map(function(_ref3,i){var x=_ref3.x,y=_ref3.y,rot=_ref3.rot,scale=_ref3.scale;return/*#__PURE__*/_jsx(animated.div,{style:{transform:interpolate([x,y],function(x,y){return\"translate3d(\".concat(x,\"px,\").concat(y,\"px,0)\");})},children:/*#__PURE__*/_jsx(animated.div,_objectSpread(_objectSpread({},bind(i)),{},{style:{transform:interpolate([rot,scale],trans),backgroundImage:\"url(\".concat(cards[i],\")\")}}))},i);});}render(/*#__PURE__*/_jsx(Deck,{}),document.getElementById('root'));","map":{"version":3,"sources":["C:/Users/56994/Desktop/vercel/src/index.js"],"names":["render","React","useState","useSprings","animated","interpolate","useGesture","cards","to","i","x","y","scale","rot","Math","random","delay","from","trans","r","s","Deck","Set","gone","length","props","set","bind","args","index","down","delta","xDelta","distance","direction","xDir","velocity","trigger","dir","add","isGone","has","window","innerWidth","undefined","config","friction","tension","size","setTimeout","clear","map","transform","backgroundImage","document","getElementById"],"mappings":"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","sourcesContent":["import { render } from 'react-dom'\r\nimport React, { useState } from 'react'\r\nimport { useSprings, animated, interpolate } from 'react-spring'\r\nimport { useGesture } from 'react-with-gesture'\r\nimport './styles.css'\r\n\r\nconst cards = [\r\n  'https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg',\r\n  'https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg',\r\n  'https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg',\r\n]\r\n\r\n// These two are just helpers, they curate spring data, values that are later being interpolated into css\r\nconst to = (i) => ({ x: 0, y: i * -4, scale: 1, rot: -10 + Math.random() * 20, delay: i * 100 })\r\nconst from = (i) => ({ x: 0, y: i * -4, rot: 0, scale: 1.5, y: -1000 })\r\n// This is being used down there in the view, it interpolates rotation and scale into a css transform\r\nconst trans = (r, s) => `perspective(1500px) rotateX(30deg) rotateY(${r / 10}deg) rotateZ(${r}deg) scale(${s})`\r\n\r\nfunction Deck() {\r\n  const [gone] = useState(() => new Set()) // The set flags all the cards that are flicked out\r\n  const [props, set] = useSprings(cards.length, (i) => ({ ...to(i), from: from(i) })) // Create a bunch of springs using the helpers above\r\n  // Create a gesture, we're interested in down-state, delta (current-pos - click-pos), direction and velocity\r\n  const bind = useGesture(({ args: [index], down, delta: [xDelta], distance, direction: [xDir], velocity }) => {\r\n    const trigger = velocity > 0.15 // If you flick hard enough it should trigger the card to fly out\r\n    const dir = xDir < 0 ? -1 : 1 // Direction should either point left or right\r\n    if (!down && trigger) gone.add(index) // If button/finger's up and trigger velocity is reached, we flag the card ready to fly out\r\n    set((i) => {\r\n      if (index !== i) return // We're only interested in changing spring-data for the current spring\r\n      const isGone = gone.has(index)\r\n      const x = isGone ? (200 + window.innerWidth) * dir : down ? xDelta : 0 // When a card is gone it flys out left or right, otherwise goes back to zero\r\n      const rot = xDelta / 100 + (isGone ? dir * 10 * velocity : 0) // How much the card tilts, flicking it harder makes it rotate faster\r\n      const scale = down ? 1.1 : 1 // Active cards lift up a bit\r\n      return { x, rot, scale, delay: undefined, config: { friction: 50, tension: down ? 800 : isGone ? 200 : 500 } }\r\n    })\r\n    if (!down && gone.size === cards.length) setTimeout(() => gone.clear() || set((i) => to(i)), 6000)\r\n  })\r\n  // Now we're just mapping the animated values to our view, that's it. Btw, this component only renders once. :-)\r\n  return props.map(({ x, y, rot, scale }, i) => (\r\n    <animated.div key={i} style={{ transform: interpolate([x, y], (x, y) => `translate3d(${x}px,${y}px,0)`) }}>\r\n      {/* This is the card itself, we're binding our gesture to it (and inject its index so we know which is which) */}\r\n      <animated.div {...bind(i)} style={{ transform: interpolate([rot, scale], trans), backgroundImage: `url(${cards[i]})` }} />\r\n    </animated.div>\r\n  ))\r\n}\r\n\r\nrender(<Deck />, document.getElementById('root'))\r\n"]},"metadata":{},"sourceType":"module"}